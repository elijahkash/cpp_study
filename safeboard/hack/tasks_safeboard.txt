1, 2, 5(доделать)

Условие
Для общения по небезопасному каналу два друга разработали некоторый алгоритм передачи сообщения.
Данные передаются в виде последовательности целых чисел, расположенных в особом порядке: разница по модулю между двумя соседними членами не превышает длину последовательности. При передаче порядок некоторых чисел случайным образом меняется, но исходная последовательность все еще может содержать корректные подпоследовательности, закодированные по исходным правилам.
Требуется найти максимальную корректную непрерывную подпоследовательность и вывести ее длину.

Примеры
для последовательности: {1, 2, 3, 4}, разница между любыми соседними членами равна 1, длина максимальной корректной подпоследовательности равна 4
для последовательности: {6, 2, 3, -2}, разница между соседними членами равна 4, 1, 5, соответственно максимальная корректная подпоследовательность {2, 3}, её длина 2.

Вход.
На вход дается последовательность в виде
1 2 3 4 5 6
Количество элементов 1..100000000
Каждый элемент - целое число в диапазоне -100000..100000

Выход.
Количество элементов в максимальной корректной подпоследовательности.

Sample Input:

1 2 3 4 5 6 7
Sample Output:

7















Условие
Есть три подвида микроорганизмов A, B, C. Взаимодействуя попарно, две особи порождают третью по следующим правилам:

Взаимодействуют соседние особи одного поколения (см. пример)
Если особи одного подвида, то и порождается этот же подвид, пример: (A, A) –> A
Если особи разного подвида, то порождается особь всегда отличная от обоих родителей, примеры (A, B) –> C , (C, A) –> B и т.п.
На вход подается последовательность родителей первого поколения в виде строки составленной из символов A,B,C без пробелов длиной L символов.

Где 1<L<512

Задача сказать какого подвида будет финальный потомок: A или B или C

Пример
Дано

ABBCAA

Решение

Рассмотрим взаимодействие AB, затем BB затем BC и тп и выпишем потомков, повторим до достижения финала когда останется 1 особь:

A B B C A A

 C B A B A

  A C C C

   B C C

    A C

     B


Ответ

B

Sample Input:

BABCBBAABCBACCBBAB
Sample Output:

A




















Задержки в сети
Есть сеть с N узлами, M двунаправленными соединениями между ними и пакетами, гуляющими по ней. Прохождение пакета через соединение происходит с целочисленной задержкой Pi. Суммарная задержка между узлами в пути M1, M2, M3 … Mk измеряется за счет побитового «или» всех задержек в пути P1 or P2 or P3 … or Pk.

Необходимо отыскать путь для пакета с минимальной задержкой между двумя заданными A и B узлами и вывести задержку.

Входные данные:

Первая строка содержит два числа: кол-во узлов N( 1<=N<=1000) и M(1<= M <= 10000)
Далее M строк: каждая i-ая строка содержат информацию о соединении между Ui и Vi и задержку Pi (1<= Ui,Vi <= N, 1<= Pi<= 1024)
Далее строка содержащая: A и B

Выходные данные: Задержка между A и B, если пути нет, то вывести -1

Оптимальный путь для примера ниже:
1->2->3 ( 4 | 4 = 4 )

Sample Input:

3 4
1 2 4
2 3 4
1 3 10
1 3 1000
1 3
Sample Output:

4


















После изучения древних текстов археолог Джон обнаружил тайные гробницы, расположенные под землей.  Для организации раскопок ему нужно узнать точное количество гробниц с сокровищами. Для этого он применяет специальный сканер, который реагирует на сокровища. Если сокровища находятся рядом друг с другом, то Джон считает, что они лежат в одной гробнице

Дана матрица m x n, (m,n>=0 и <10000) состоящая из элементов 1 и 0. 1 обозначает наличие сокровища, 0 обозначает отсутствие сокровища. Нужно определить количество гробниц.

Гробницей мы считаем непрерывную область с сокровищами. Два сокровища лежат в одной области, если они являются соседями (по горизонтали или вертикали). Считаем, что вне карты нет ни одной гробницы.



Пример

Input (пробелы, знаки табуляции и знаки конца строки следует игнорировать):

[

  [1,1,1,1,0],

  [1,1,1,1,0],

  [1,1,0,1,1],

  [1,1,0,0,0]

]

Output: 1

Sample Input:

[
  [1,1,1,1,1],
  [1,0,0,0,1],
  [1,0,0,0,1],
  [1,0,0,0,1],
  [1,0,0,0,1],
  [1,0,0,0,1],
  [1,1,1,1,1]
    ]
Sample Output:

1
























Дано натуральное число K, а так же набор A из N массивов натуральных чисел с максимальной длиной M, расположенных вертикально друг под другом и выравненных по левому краю.


Путем от верхнего до нижнего ряда называется массив из N чисел вышеуказанного набора, проходящий через все ряды, для которого каждый следующий элемент пути на один ряд ниже предыдущего по вертикали, и его позиция по горизонтали отличается от позиции предыдущего элемента не более, чем на K (в любую сторону).


Например, c A[0][1] при K = 1 можно перейти на A[1][0] (вниз и влево на 1), A[1][1] (вниз), A[1][2] (вниз и право на 1). Путь может начинаться с любого элемента верхнего ряда и включает также элементы первого и последнего ряда (старт и финиш).


Требуется найти минимально возможную сумму элементов пути. В случае, если пути не существует, вернуть -1.

0 <= N <= 100
0 <= M <= 100
0 <= K <= 100

Пример 1:
[1 2 3]
[4 5 6 7 8 9]
[10]

K = 1

Ответ: 15
Обьяснение:
Из всех возможных путей [1, 4, 10], [1, 5, 10], [2, 4, 10], [2, 5, 10], [3, 5, 10] наименьшей суммой элементов обладает [1, 4, 10]. Таким образом, ответ: 1 + 4 + 10 = 15.
---

Пример 2:
[1 2 3]
[]
[6]

K = 1

Ответ: -1
Обьяснение:
Так как промежуточный массив пуст, построить путь невозможно.

Формат ввода:
K
N
m1
val1 val2 val3
m2
val1 val2


Sample Input:

1
3
3
1 2 3
2
4 5
1
6
Sample Output:

11






















Напишите программу, которая находит кратчайший путь в "стрелочном лабиринте". Стрелочный лабиринт представляет собой квадратное поле, в каждой клетке которого расставлены стрелки, обозначающие возможные направления движения. Правила движения в лабиринте:

1) Движение начинается с заданной стартовой клетки

2) Ход можно сделать на любую клетку по направлению, в котором указывает стрелка в той клетке, откуда начинается ход.

3) Лабиринт считается пройденным, когда очередной ход заканчивается на одной из целевых клеток.



Входные данные
Программа получает на вход описание лабиринта в виде строки. Пример строки: 2006165

Первая цифра -- размерность лабиринта. В примере размерность лабиринта 2x2.

Две следующие цифры -- строка и столбец положения начальной клетки. В примере координаты начальной точки (0, 0).

Дальше идет описание лабиринта по строкам. Если размерность лабиринта N , то после стартовой клетки будет N групп по N символов, каждая из которых описывает расстановку стрелок в соответствующей строке лабиринта. Пример  2006165 описывает следующий лабиринт:

6	1
6	5
Направления движения кодируются следующим образом:

7 -- северо-запад	8 -- север	9 -- северо-восток
4 -- запад	 	6 -- восток
1 -- юго-запад	2 -- юг	3 -- юго-восток
Число 5 обозначает целевую клетку (их может быть несколько).



Выходные данные
Программа должна выдавать строку с последовательностью ходов. Каждый ход кодируется координатами клетки (строка, столбец). Ходы разделяются символом ; . Пример строки, решающей приведенный выше лабиринт: (0, 1);(1, 0);(1, 1);

Sample Input 1:

2006165
Sample Output 1:

(0, 1);(1, 0);(1, 1);
Sample Input 2:

300621621654
Sample Output 2:

(0, 1);(2, 1);
Sample Input 3:

301311625654
Sample Output 3:

(1, 0);(1, 2);






















Описание:

Недавно у нас был написан код, активно использующий исключения для обработки ошибок. В частности, использовался механизм std::nested_exception, чтобы исключения можно было объединять в "цепочку"; затем, в финальном блоке catch() выводить в лог всю последовательность событий, приведших к ошибке - это сильно упрощает диагностику проблем.

Однако у нас возникли сомнения, не приведет ли такой подход к падению производительности. Поэтому мы взяли небольшой кусочек такого кода и просим вас переписать его без использования исключений, сохранив логику. Сообщения об ошибках должны выглядеть так же, как в текущем коде. Все функции должны быть объявлены noexcept, использовать конструкции try/catch запрещается.

В дальнейшем мы сможем взять два этих "эквивалентных" кода и в реальных условиях измерить их быстродействие (это в текущую задачу не входит).

Пример кода с исключениями:

#include <iostream>
#include <exception>
#include <fstream>
#include <vector>
#include <algorithm>
#include <map>
#include <sstream>

using namespace std;
struct Requester
{
    string name;
    uint64_t ownerId;
};

struct RequestFromConfig
{
    string name;
    string requester;
    string type;
};

enum class RequestType
{
    Drop, Apply, Validate
};

struct Request
{
    RequestType type;
    uint64_t ownerId;
};

RequestType GetRequestType(const RequestFromConfig& request)
{
    if (request.type == "drop")
        return RequestType::Drop;
    if (request.type == "apply")
        return RequestType::Apply;
    if (request.type == "validate")
        return RequestType::Validate;
    throw runtime_error(string("unknown type '") + request.type + "'");
}

Request BuildRequest(const vector<Requester>& availableRequesters, const RequestFromConfig& requestFromConfig)
{

    Request request;
    auto it = find_if(begin(availableRequesters), end(availableRequesters), [&](const Requester& requester)
        {return requester.name == requestFromConfig.requester; });
    if (it == end(availableRequesters))
        throw runtime_error(string("unknown requester '") + requestFromConfig.requester + "'");
    request.type = GetRequestType(requestFromConfig);
    request.ownerId = it->ownerId;
    return request;

}
struct Queue
{
    uint32_t id;
    vector<Request> requests;
};
Queue BuildRequestQueue(const vector<Requester>& availableRequesters, const vector<RequestFromConfig>& requests)
{
    static uint32_t nextId = 0;
    nextId++;
    try
    {
        Queue result;
        result.id = nextId;
        for (const auto& requestFromConfig : requests)
            result.requests.push_back(BuildRequest(availableRequesters, requestFromConfig));
        return result;
    }

    catch (...)
    {
        ostringstream message("");
        message << "can't build request queue #" << nextId;
        std::throw_with_nested(std::runtime_error(message.str()));
    }
}

void print_exception(const std::exception& e, int level = 0)
{
    cout << string(level, ' ') << (level ? "because: " : "high-level operation failed: ") << e.what() << '\n';
    try
    {
        std::rethrow_if_nested(e);
    }
    catch (const std::exception& e)
    {
        print_exception(e, level + 1);
    }
    catch (...) {}
}
void PrintTaskResult(const vector<Requester>& availableRequesters, const vector<RequestFromConfig>& requests)
{
    try
    {
        auto queue = BuildRequestQueue(availableRequesters, requests);
        for (const auto& request : queue.requests)
            cout << "request in queue #" << queue.id << ": " << static_cast<int>(request.type) << " / " << request.ownerId << endl;
    }
    catch (const std::exception& ex)
    {
        print_exception(ex);
    }
    cout << endl << endl;
}

///////////////////////////////////////////////////////////////////////////////

int main() // examples
{
    PrintTaskResult(
        { { "first_requester", 1 }, { "second_requester", 2 }, { "third_requester", 3 } },
        { { "Johny", "second_requester", "drop" }, { "Sam", "second_requester", "apply" }, { "Louise", "first_requester", "apply" } });
    /* [output]

    request in queue #1: 0 / 2
    request in queue #1: 1 / 2
    request in queue #1: 1 / 1

    */
    PrintTaskResult(
        { { "second_requester", 2 }, { "third_requester", 3 } },
        { { "Johny", "second_requester", "drop" }, { "Sam", "second_requester", "apply" }, { "Louise", "first_requester", "apply" } });
    /* [output]

    high-level operation failed: can't build request queue #2
     because: unknown requester 'first_requester'
    */

    PrintTaskResult(
        { { "first_requester", 1 }, { "second_requester", 2 }, { "third_requester", 3 } },
        { { "Johny", "third_requester", "drop" }, { "Sam", "third_requester", "apply" }, { "Louise", "first_requester", "apply" } });

    /* [output]
    request in queue #3: 0 / 3
    request in queue #3: 1 / 3
    request in queue #3: 1 / 1
    */

    PrintTaskResult(
        { { "first_requester", 1 }, { "second_requester", 2 }, { "third_requester", 3 } },
        { { "Johny", "second_requester", "drop" }, { "Sam", "second_requester", "apply" }, { "Louise", "first_requester", "reapply" } });
    /* [output]
    high-level operation failed: can't build request queue #4
     because: unknown type 'reapply'
    */
    return 0;
}





















Детектирование DOS-атаки на сервер

Описание:

В очень серьезной организации ООО "Мыло ручной лепки" есть сайт, который располагается на собственном сервере. Вся важнейшая хозяйственная и торговая деятельность организации ведется через этот сайт. Но у компании есть серьезный и недобросовестный конкурент, который периодически устраивает DOS-атаки на сервер наших мыловаров, от чего у них приостанавливается вся продажа. Мыловары сильно озаботились этой проблемой и обратились за помощью к Вам. Они хотят, чтобы Вы написали им такую программу, которая смогла бы определять время, когда происходит атака на сервер, по логам этого самого сервера.



Условие задачи:

Сервер имеет три входящих канала для подключения клиентов. Когда клиент не подключен к каналу, канал простаивает. Когда к каналу подключен клиент, он считается занятым и к нему нельзя подключиться. Каждый канал ведет текстовый лог времени подключения и отключения клиентов следующего вида:

7

13

65

98

Каждая запись данного лога – это временная метка в секундах от старта сервера. Нечетные записи – подключения, четные – отключения. В данном примере имеем лог канала, к которому на 7-ой секунде подключился клиент, на 13 сек – отключился, на 65 сек снова подключился, на 98 - отключился. Получается, что в периоды [с 7 по 13 сек] и [с 65 по 98 сек] канал был занят.

Необходимо написать программу, которая в качестве входных аргументов функции int main(int argc, char *argv[]) принимает имена 3-ех файлов логов активности каналов, формат которых описан выше, по одному файлу на аргумент. Программа должна открыть файлы, прочитать их, проанализировать содержимое и вывести в консоль временной промежуток, когда все три канала были заняты одновременно, например, "124 135".

Если такого промежутка не нашлось, то вывести "OK". Наличие атаки в логах не гарантировано;
Если таких промежутков будет несколько, то перечислить все, каждый с новой строки;
Поддержать ситуацию, если у интервала атаки не оказалось верхней временной границы: все три лога закончились, когда их каналы были заняты. В таком случае нужно вывести в консоль только время начала атаки и многоточие, например "124 ...";
Количество записей в логах не определено и может отличаться;
Считаем, что формат данных логов стабилен и на вход программы приходят без ошибок. То есть отдельных проверок на валидность данных в файлах проводить не нужно;
Если на вход программы передано != 3 файлов с логами, вывести текст с ошибкой в консоль и завершить работу программы;
Если хотя бы один из файлов не удалось открыть, вывести текст с ошибкой в консоль и завершить работу программы;
Ограничения на объем используемой памяти нет;
Задачу нужно решить с минимальной сложностью, стремясь к O(n * m), где n - количество логов, m - максимальное количество записей в логе.


Пример:

Сервер выдал нам 3 лога со следующем содержимым:

log1.txt	log2.txt	log3.txt
7	45	2
13	63	5
98	111	23
154	152	72
161	 	135
174	 	215
Здесь мы видим, что во всех 3-ех логах нашлись такие пересекающиеся интервалы (помечены красным), когда все 3 канала были заняты одновременно.  Считаем это детектом DOS-атаки. Программа должна вывести интервал именно пересечения:

135 152


Критерий оценки:

Задача будет считаться выполненной, если

программа компилируется;
открывает указанные к аргументах файлы;
выводит хотя бы один интервал времени атаки или OK, если атаки не было.
Я ([ЛК] Игорь Кирпичев) буду на связи и смогу помочь, если условие не понятно. Могу во время работы над задачей передать примеры логов от сервера, чтобы было проще ориентироваться и отлаживать свою программу.

Проверять задачу буду так: скомпилирую у себя, прогоню несколько тестовых данных, посмотрю код. Если будут замечания, покажу что и где лучше поправить.

Передавать мне решение задачи можно любым удобным способом: ссылка на GitHub, текстовый файл или иное.




























Выбор оптимального сервера сканирования угроз


Описание:
В многопоточной среде существует огромное множество клиентов, которым необходимо выполнить сканирования угроз на удаленном сервере. Серверов также великое множество. Многие из серверов загружены, так как уже обслуживают достаточно большое количество клиентов, обрабатывая запросы на сканирование угроз. Решая задачу выбора оптимального сервера сканирования, придумали несколько алгоритмов. Сервера наделили параметрами с помощью которых возможно принять оптимальное решение - количеством клиентов, тэгами (чтобы распределить сервера и клиентов на группы), расположением относительно клиентов. Но оказалось, что процесс выбора достаточно ресурсоемкий - было решено делегировать его некому фасаду, через который возможно было бы получать информацию об оптимальном сервере.

Необходимо реализовать компонент ServerProvider. ServerProvider отвечает за выбор оптимального сервера сканирования и обрабатывает запросы от клиентов, возвращая адрес выбранного сервера сканирования.

Схему взаимодействия можно представить следующим образом:



Множество клиентов запрашивают у ServerProvider адрес сервера сканирования.



ServerProvider при выборе сервера использует один из алгоритмов выбора и, самое важное, список серверов сканирования. Все параметры ServerProvider получает с настройками от администраторов системы. Стоит учесть, что изменение или запрос текущих настроек может произойти в любое время, параллельно с процессом выбора или запроса информации об оптимальном сервере.



Условия:
Необходимо учесть, что компонент ServerProvider работает в многопоточной среде. Вызов любого метода может произойти параллельно с любым другим. Особое внимание уделить синхронизации для обеспечения валидного доступа к данным. Реализация компонента должна гарантировать безопасный выход из приложения (освобождение ресурсов, завершение потока и т.д).

ServerProvider реализует следующие интерфейсы: IServerProvider и IServerProviderSettings. Интерфейсы предполагают использование обработки ошибок через коды возврата (не через проброс исключений) - каждый метод интерфейса возвращает один из элементов enum ResultCode в зависимости от результата.

В настройках ServerProvider передается тип используемого алгоритма (searchMode) и параметры алгоритмов (localSearchSettings, smartSearchSettings) - изменение настроек приводит к изменению используемого алгоритма выбора. ServerProvider в момент инициализации запускает поток и с интервалом 30 секунд производит выбор оптимального сервера, учитывая текущие настройки. Использование потока - обязательное условие. Запускать процесс выбора в вызове GetRemoteServiceAddress от клиента к ServerProvider нельзя, так как процесс выбора может занимать достаточно продолжительное время, что привело бы к ожиданиям на стороне клиента.

Алгоритмов выбор сервера два: Local и Smart.

Вход и выход алгоритмов идентичен:

На вход подается текущий сервер (либо структура с пустым адресом, как признак отсутствия текущего сервера) и список серверов сканирования (servers);
На выходе алгоритм отдает выбранный сервер (может совпадать с текущим, если текущий сервер все еще является оптимальным) и результат выбора (успех, либо ошибка - в случае возврата ошибки на выходе алгоритма - ServerProvider считает, что сервер в данный момент недоступен);
Алгоритм Local: выполняется поиск сервера с наименьшим количеством подключенных клиентов (поле clients) и с полем AreaLevel равному City. Если серверов с полем AreaLevel равному City нет - поиск выполняется по всему списку серверов. Если на вход передается текущий сервер, и оптимальный сервер (выбранный алгоритмом) не равен текущему - на выход алгоритма отдается либо текущий сервер, либо оптимальный (новый), в случае если разница в количестве клиентов больше определенного порога (diffInClients).

Алгоритм Smart: выполняется поиск сервера с наименьшим количеством подключенных клиентов (поле clients), подходящими тэгами (tag сервера совпадает с одним из тэгов ServerProvider (tags)), а также с полем AreaLevel не превосходящему ограничение по AreaLevel (areaLevelRestriction). Если серверов подходящих под ограничения по тэгам либо AreaLevel нет - возвращается ошибка. Если на вход передается текущий сервер, и оптимальный сервер (выбранный) не равен текущему - на выход алгоритма отдается либо текущий сервер, либо оптимальный (новый), в случае если разница разница в количестве клиентов текущего и выбранного более определенного процента (diffInClientsPercents) от общей нагрузки всех подходящих под ограничения серверов.



Формат решения:
В качестве решения необходимо прислать код - реализацию компонентов. Код должен успешно компилироваться, например в MSVS. Основной метод может выглядеть, примерно, так (будет отлично, но не обязательно, если в основном методе будут использованы потоки, чтобы протестировать собственный код в многопоточной среде):

main...
{
    ServerProvider serverProvider;
    ...
    ServerProviderSettings settings;
    std::vector<RemoteService> servers = { "3000, City, "", "10.70.140.80"", "0, Country, "", "10.70.140.81"", ... };
    settings.servers = servers;
    serverProvider.SetSettings(settings);
    ...
    serverProvider.GetRemoteServiceAddress(...);
    ...
    ServerProviderSettings settings;
    settings.searchMode = Smart;
    settings.areaLevel = Country;
    ...
    serverProvider.GetRemoteServiceAddress(...);
...


Контракты:
namespace remote
{
enum ResultCode
{
    Ok = 0,
    Fail,
    Undefined
};

struct IServerProvider
{
    // address (out):
    //   Address of current scan server (choosen by last iteration of algorithm call)
    // return:
    //   Ok on success
    //   Fail in case of any errors
    //   Undefined in case of current scan server is undefined (there was no optimal server by last last iteration of algorithm call)
    virtual ResultCode GetRemoteServiceAddress(std::string& address) = 0;
};

const uint32_t DiffInClientsDefaultForLocal = 50;
struct LocalSearchSettings
{
    uint32_t diffInClients;

    LocalSearchSettings()
        : diffInClients(DiffInClientsDefaultForLocal) {}
};

enum AreaLevel
{
    City = 0,
    Country,
    Area,
    None
};

const uint32_t DiffInClientsDefaultForSmartPercents = 20;
struct SmartSearchSettings
{
    uint32_t diffInClientsPercents;

    // Set of tags with delimer equal to #
    // Example: "tag0#tag1#tag2"
	std::string tags;

    AreaLevel areaLevelRestriction;

    SmartSearchSettings()
        : diffInClientsPercents(DiffInClientsDefaultForSmartPercents)
        , areaLevelRestriction(None) {}
};

// Information about one of scan servers, one of an item in "std::vector<RemoteService> servers" collection,
// passed by an admin to ServerProvider via IServerProviderSettings
struct RemoteService
{
    uint32_t clients;

    AreaLevel areaLevel;

    std::string tag;

    std::string address;

    RemoteService()
        : clients(0)
        , areaLevel(None) {}
};

enum SearchMode
{
    Local = 0,
    Smart
};
struct ServerProviderSettings
{
    // Scan server addresses colletion to choose optimal from.
    // Initialy empty, sets by an admin.
    std::vector<RemoteService> servers;

    // One of two algorithm to use for choose of scan server
    SearchMode searchMode;

    LocalSearchSettings localSearchSettings;
    SmartSearchSettings smartSearchSettings;

    ServerProviderSettings()
        : searchMode(Local) {}
};

struct IServerProviderSettings
{
    // settings (in)
    // return:
    //   Ok on success
    //   Fail in case of any errors
    virtual uint32_t SetSettings(const ServerProviderSettings* settings) = 0;
    // settings (out)
    // return:
    //   Ok on success
    //   Fail in case of any errors
    virtual uint32_t GetSettings(ServerProviderSettings* settings) = 0;
};
} // namespace remote