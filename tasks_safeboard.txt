1, 2, 5(доделать)

Условие
Для общения по небезопасному каналу два друга разработали некоторый алгоритм передачи сообщения.
Данные передаются в виде последовательности целых чисел, расположенных в особом порядке: разница по модулю между двумя соседними членами не превышает длину последовательности. При передаче порядок некоторых чисел случайным образом меняется, но исходная последовательность все еще может содержать корректные подпоследовательности, закодированные по исходным правилам.
Требуется найти максимальную корректную непрерывную подпоследовательность и вывести ее длину.

Примеры
для последовательности: {1, 2, 3, 4}, разница между любыми соседними членами равна 1, длина максимальной корректной подпоследовательности равна 4
для последовательности: {6, 2, 3, -2}, разница между соседними членами равна 4, 1, 5, соответственно максимальная корректная подпоследовательность {2, 3}, её длина 2.

Вход.
На вход дается последовательность в виде
1 2 3 4 5 6
Количество элементов 1..100000000
Каждый элемент - целое число в диапазоне -100000..100000

Выход.
Количество элементов в максимальной корректной подпоследовательности.

Sample Input:

1 2 3 4 5 6 7
Sample Output:

7















Условие
Есть три подвида микроорганизмов A, B, C. Взаимодействуя попарно, две особи порождают третью по следующим правилам:

Взаимодействуют соседние особи одного поколения (см. пример)
Если особи одного подвида, то и порождается этот же подвид, пример: (A, A) –> A
Если особи разного подвида, то порождается особь всегда отличная от обоих родителей, примеры (A, B) –> C , (C, A) –> B и т.п.
На вход подается последовательность родителей первого поколения в виде строки составленной из символов A,B,C без пробелов длиной L символов.

Где 1<L<512

Задача сказать какого подвида будет финальный потомок: A или B или C

Пример
Дано

ABBCAA

Решение

Рассмотрим взаимодействие AB, затем BB затем BC и тп и выпишем потомков, повторим до достижения финала когда останется 1 особь:

A B B C A A

 C B A B A

  A C C C

   B C C

    A C

     B


Ответ

B

Sample Input:

BABCBBAABCBACCBBAB
Sample Output:

A




















Задержки в сети
Есть сеть с N узлами, M двунаправленными соединениями между ними и пакетами, гуляющими по ней. Прохождение пакета через соединение происходит с целочисленной задержкой Pi. Суммарная задержка между узлами в пути M1, M2, M3 … Mk измеряется за счет побитового «или» всех задержек в пути P1 or P2 or P3 … or Pk.

Необходимо отыскать путь для пакета с минимальной задержкой между двумя заданными A и B узлами и вывести задержку.

Входные данные:

Первая строка содержит два числа: кол-во узлов N( 1<=N<=1000) и M(1<= M <= 10000)
Далее M строк: каждая i-ая строка содержат информацию о соединении между Ui и Vi и задержку Pi (1<= Ui,Vi <= N, 1<= Pi<= 1024)
Далее строка содержащая: A и B

Выходные данные: Задержка между A и B, если пути нет, то вывести -1

Оптимальный путь для примера ниже:
1->2->3 ( 4 | 4 = 4 )

Sample Input:

3 4
1 2 4
2 3 4
1 3 10
1 3 1000
1 3
Sample Output:

4


















После изучения древних текстов археолог Джон обнаружил тайные гробницы, расположенные под землей.  Для организации раскопок ему нужно узнать точное количество гробниц с сокровищами. Для этого он применяет специальный сканер, который реагирует на сокровища. Если сокровища находятся рядом друг с другом, то Джон считает, что они лежат в одной гробнице

Дана матрица m x n, (m,n>=0 и <10000) состоящая из элементов 1 и 0. 1 обозначает наличие сокровища, 0 обозначает отсутствие сокровища. Нужно определить количество гробниц.

Гробницей мы считаем непрерывную область с сокровищами. Два сокровища лежат в одной области, если они являются соседями (по горизонтали или вертикали). Считаем, что вне карты нет ни одной гробницы.



Пример

Input (пробелы, знаки табуляции и знаки конца строки следует игнорировать):

[

  [1,1,1,1,0],

  [1,1,1,1,0],

  [1,1,0,1,1],

  [1,1,0,0,0]

]

Output: 1

Sample Input:

[
  [1,1,1,1,1],
  [1,0,0,0,1],
  [1,0,0,0,1],
  [1,0,0,0,1],
  [1,0,0,0,1],
  [1,0,0,0,1],
  [1,1,1,1,1]
    ]
Sample Output:

1
























Дано натуральное число K, а так же набор A из N массивов натуральных чисел с максимальной длиной M, расположенных вертикально друг под другом и выравненных по левому краю.


Путем от верхнего до нижнего ряда называется массив из N чисел вышеуказанного набора, проходящий через все ряды, для которого каждый следующий элемент пути на один ряд ниже предыдущего по вертикали, и его позиция по горизонтали отличается от позиции предыдущего элемента не более, чем на K (в любую сторону).


Например, c A[0][1] при K = 1 можно перейти на A[1][0] (вниз и влево на 1), A[1][1] (вниз), A[1][2] (вниз и право на 1). Путь может начинаться с любого элемента верхнего ряда и включает также элементы первого и последнего ряда (старт и финиш).


Требуется найти минимально возможную сумму элементов пути. В случае, если пути не существует, вернуть -1.

0 <= N <= 100
0 <= M <= 100
0 <= K <= 100

Пример 1:
[1 2 3]
[4 5 6 7 8 9]
[10]

K = 1

Ответ: 15
Обьяснение:
Из всех возможных путей [1, 4, 10], [1, 5, 10], [2, 4, 10], [2, 5, 10], [3, 5, 10] наименьшей суммой элементов обладает [1, 4, 10]. Таким образом, ответ: 1 + 4 + 10 = 15.
---

Пример 2:
[1 2 3]
[]
[6]

K = 1

Ответ: -1
Обьяснение:
Так как промежуточный массив пуст, построить путь невозможно.

Формат ввода:
K
N
m1
val1 val2 val3
m2
val1 val2


Sample Input:

1
3
3
1 2 3
2
4 5
1
6
Sample Output:

11






















Напишите программу, которая находит кратчайший путь в "стрелочном лабиринте". Стрелочный лабиринт представляет собой квадратное поле, в каждой клетке которого расставлены стрелки, обозначающие возможные направления движения. Правила движения в лабиринте:

1) Движение начинается с заданной стартовой клетки

2) Ход можно сделать на любую клетку по направлению, в котором указывает стрелка в той клетке, откуда начинается ход.

3) Лабиринт считается пройденным, когда очередной ход заканчивается на одной из целевых клеток.



Входные данные
Программа получает на вход описание лабиринта в виде строки. Пример строки: 2006165

Первая цифра -- размерность лабиринта. В примере размерность лабиринта 2x2.

Две следующие цифры -- строка и столбец положения начальной клетки. В примере координаты начальной точки (0, 0).

Дальше идет описание лабиринта по строкам. Если размерность лабиринта N , то после стартовой клетки будет N групп по N символов, каждая из которых описывает расстановку стрелок в соответствующей строке лабиринта. Пример  2006165 описывает следующий лабиринт:

6	1
6	5
Направления движения кодируются следующим образом:

7 -- северо-запад	8 -- север	9 -- северо-восток
4 -- запад	 	6 -- восток
1 -- юго-запад	2 -- юг	3 -- юго-восток
Число 5 обозначает целевую клетку (их может быть несколько).



Выходные данные
Программа должна выдавать строку с последовательностью ходов. Каждый ход кодируется координатами клетки (строка, столбец). Ходы разделяются символом ; . Пример строки, решающей приведенный выше лабиринт: (0, 1);(1, 0);(1, 1);

Sample Input 1:

2006165
Sample Output 1:

(0, 1);(1, 0);(1, 1);
Sample Input 2:

300621621654
Sample Output 2:

(0, 1);(2, 1);
Sample Input 3:

301311625654
Sample Output 3:

(1, 0);(1, 2);






















Описание:

Недавно у нас был написан код, активно использующий исключения для обработки ошибок. В частности, использовался механизм std::nested_exception, чтобы исключения можно было объединять в "цепочку"; затем, в финальном блоке catch() выводить в лог всю последовательность событий, приведших к ошибке - это сильно упрощает диагностику проблем.

Однако у нас возникли сомнения, не приведет ли такой подход к падению производительности. Поэтому мы взяли небольшой кусочек такого кода и просим вас переписать его без использования исключений, сохранив логику. Сообщения об ошибках должны выглядеть так же, как в текущем коде. Все функции должны быть объявлены noexcept, использовать конструкции try/catch запрещается.

В дальнейшем мы сможем взять два этих "эквивалентных" кода и в реальных условиях измерить их быстродействие (это в текущую задачу не входит).

Пример кода с исключениями:

#include <iostream>
#include <exception>
#include <fstream>
#include <vector>
#include <algorithm>
#include <map>
#include <sstream>

using namespace std;
struct Requester
{
    string name;
    uint64_t ownerId;
};

struct RequestFromConfig
{
    string name;
    string requester;
    string type;
};

enum class RequestType
{
    Drop, Apply, Validate
};

struct Request
{
    RequestType type;
    uint64_t ownerId;
};

RequestType GetRequestType(const RequestFromConfig& request)
{
    if (request.type == "drop")
        return RequestType::Drop;
    if (request.type == "apply")
        return RequestType::Apply;
    if (request.type == "validate")
        return RequestType::Validate;
    throw runtime_error(string("unknown type '") + request.type + "'");
}

Request BuildRequest(const vector<Requester>& availableRequesters, const RequestFromConfig& requestFromConfig)
{

    Request request;
    auto it = find_if(begin(availableRequesters), end(availableRequesters), [&](const Requester& requester)
        {return requester.name == requestFromConfig.requester; });
    if (it == end(availableRequesters))
        throw runtime_error(string("unknown requester '") + requestFromConfig.requester + "'");
    request.type = GetRequestType(requestFromConfig);
    request.ownerId = it->ownerId;
    return request;

}
struct Queue
{
    uint32_t id;
    vector<Request> requests;
};
Queue BuildRequestQueue(const vector<Requester>& availableRequesters, const vector<RequestFromConfig>& requests)
{
    static uint32_t nextId = 0;
    nextId++;
    try
    {
        Queue result;
        result.id = nextId;
        for (const auto& requestFromConfig : requests)
            result.requests.push_back(BuildRequest(availableRequesters, requestFromConfig));
        return result;
    }

    catch (...)
    {
        ostringstream message("");
        message << "can't build request queue #" << nextId;
        std::throw_with_nested(std::runtime_error(message.str()));
    }
}

void print_exception(const std::exception& e, int level = 0)
{
    cout << string(level, ' ') << (level ? "because: " : "high-level operation failed: ") << e.what() << '\n';
    try
    {
        std::rethrow_if_nested(e);
    }
    catch (const std::exception& e)
    {
        print_exception(e, level + 1);
    }
    catch (...) {}
}
void PrintTaskResult(const vector<Requester>& availableRequesters, const vector<RequestFromConfig>& requests)
{
    try
    {
        auto queue = BuildRequestQueue(availableRequesters, requests);
        for (const auto& request : queue.requests)
            cout << "request in queue #" << queue.id << ": " << static_cast<int>(request.type) << " / " << request.ownerId << endl;
    }
    catch (const std::exception& ex)
    {
        print_exception(ex);
    }
    cout << endl << endl;
}

///////////////////////////////////////////////////////////////////////////////

int main() // examples
{
    PrintTaskResult(
        { { "first_requester", 1 }, { "second_requester", 2 }, { "third_requester", 3 } },
        { { "Johny", "second_requester", "drop" }, { "Sam", "second_requester", "apply" }, { "Louise", "first_requester", "apply" } });
    /* [output]

    request in queue #1: 0 / 2
    request in queue #1: 1 / 2
    request in queue #1: 1 / 1

    */
    PrintTaskResult(
        { { "second_requester", 2 }, { "third_requester", 3 } },
        { { "Johny", "second_requester", "drop" }, { "Sam", "second_requester", "apply" }, { "Louise", "first_requester", "apply" } });
    /* [output]

    high-level operation failed: can't build request queue #2
     because: unknown requester 'first_requester'
    */

    PrintTaskResult(
        { { "first_requester", 1 }, { "second_requester", 2 }, { "third_requester", 3 } },
        { { "Johny", "third_requester", "drop" }, { "Sam", "third_requester", "apply" }, { "Louise", "first_requester", "apply" } });

    /* [output]
    request in queue #3: 0 / 3
    request in queue #3: 1 / 3
    request in queue #3: 1 / 1
    */

    PrintTaskResult(
        { { "first_requester", 1 }, { "second_requester", 2 }, { "third_requester", 3 } },
        { { "Johny", "second_requester", "drop" }, { "Sam", "second_requester", "apply" }, { "Louise", "first_requester", "reapply" } });
    /* [output]
    high-level operation failed: can't build request queue #4
     because: unknown type 'reapply'
    */
    return 0;
}





















Детектирование DOS-атаки на сервер

Описание:

В очень серьезной организации ООО "Мыло ручной лепки" есть сайт, который располагается на собственном сервере. Вся важнейшая хозяйственная и торговая деятельность организации ведется через этот сайт. Но у компании есть серьезный и недобросовестный конкурент, который периодически устраивает DOS-атаки на сервер наших мыловаров, от чего у них приостанавливается вся продажа. Мыловары сильно озаботились этой проблемой и обратились за помощью к Вам. Они хотят, чтобы Вы написали им такую программу, которая смогла бы определять время, когда происходит атака на сервер, по логам этого самого сервера.



Условие задачи:

Сервер имеет три входящих канала для подключения клиентов. Когда клиент не подключен к каналу, канал простаивает. Когда к каналу подключен клиент, он считается занятым и к нему нельзя подключиться. Каждый канал ведет текстовый лог времени подключения и отключения клиентов следующего вида:

7

13

65

98

Каждая запись данного лога – это временная метка в секундах от старта сервера. Нечетные записи – подключения, четные – отключения. В данном примере имеем лог канала, к которому на 7-ой секунде подключился клиент, на 13 сек – отключился, на 65 сек снова подключился, на 98 - отключился. Получается, что в периоды [с 7 по 13 сек] и [с 65 по 98 сек] канал был занят.

Необходимо написать программу, которая в качестве входных аргументов функции int main(int argc, char *argv[]) принимает имена 3-ех файлов логов активности каналов, формат которых описан выше, по одному файлу на аргумент. Программа должна открыть файлы, прочитать их, проанализировать содержимое и вывести в консоль временной промежуток, когда все три канала были заняты одновременно, например, "124 135".

Если такого промежутка не нашлось, то вывести "OK". Наличие атаки в логах не гарантировано;
Если таких промежутков будет несколько, то перечислить все, каждый с новой строки;
Поддержать ситуацию, если у интервала атаки не оказалось верхней временной границы: все три лога закончились, когда их каналы были заняты. В таком случае нужно вывести в консоль только время начала атаки и многоточие, например "124 ...";
Количество записей в логах не определено и может отличаться;
Считаем, что формат данных логов стабилен и на вход программы приходят без ошибок. То есть отдельных проверок на валидность данных в файлах проводить не нужно;
Если на вход программы передано != 3 файлов с логами, вывести текст с ошибкой в консоль и завершить работу программы;
Если хотя бы один из файлов не удалось открыть, вывести текст с ошибкой в консоль и завершить работу программы;
Ограничения на объем используемой памяти нет;
Задачу нужно решить с минимальной сложностью, стремясь к O(n * m), где n - количество логов, m - максимальное количество записей в логе.


Пример:

Сервер выдал нам 3 лога со следующем содержимым:

log1.txt	log2.txt	log3.txt
7	45	2
13	63	5
98	111	23
154	152	72
161	 	135
174	 	215
Здесь мы видим, что во всех 3-ех логах нашлись такие пересекающиеся интервалы (помечены красным), когда все 3 канала были заняты одновременно.  Считаем это детектом DOS-атаки. Программа должна вывести интервал именно пересечения:

135 152


Критерий оценки:

Задача будет считаться выполненной, если

программа компилируется;
открывает указанные к аргументах файлы;
выводит хотя бы один интервал времени атаки или OK, если атаки не было.
Я ([ЛК] Игорь Кирпичев) буду на связи и смогу помочь, если условие не понятно. Могу во время работы над задачей передать примеры логов от сервера, чтобы было проще ориентироваться и отлаживать свою программу.

Проверять задачу буду так: скомпилирую у себя, прогоню несколько тестовых данных, посмотрю код. Если будут замечания, покажу что и где лучше поправить.

Передавать мне решение задачи можно любым удобным способом: ссылка на GitHub, текстовый файл или иное.

